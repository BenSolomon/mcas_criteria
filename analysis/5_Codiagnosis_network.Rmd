---
title: "Co-diagnosis network analysis"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r, message = F}
source(here("utils/data_processing.R"))
source(here("utils/figures.R"))
```

# Introduction

- Goal is to model diagnoses from each criteria based on how frequently they co-occur together within a single 10-point differential diagnosis iteration.
- The rationale is that an ideal set of criteria will tend to result in a relatively similar set of diagnoses in each iteration and thus a small set of highly co-occurring diagnoses.
- Conversely, a poor set of criteria will generate highly variable diagnoses in each iteration and rates of co-occurrence will be comparatively lower.

# Import and process data
```{r, message=F}
df_gpt3 <- read_csv(here("data/processed_diagnoses/diagnoses_gpt3.csv.gz"))
df_gpt4 <- read_csv(here("data/processed_diagnoses/diagnoses_gpt4.csv.gz"))
df_gpt4_icd <- read_csv(here("data/processed_diagnoses/diagnoses_gpt4_icd.csv.gz"))
```

```{r}
# Tally each pair of co-occuring diagnoses within each criteria
df_codiag_gpt3 <- create_codiagnosis_df(df_gpt3)
df_codiag_gpt4 <- create_codiagnosis_df(df_gpt4)
df_codiag_gpt4_icd <- create_codiagnosis_df(df_gpt4_icd)
```

```{r}
df_codiag_gpt4
```

# Graph visualization

### Exploring layouts 

- To determine clearest visualization of nodes and edges

```{r, fig.width=8, fig.height=6, warning=F, message=F}
# Selecting a layout
top_n <-  200
seed <- 1234

layouts <- c("fr", "dh", "kk", "stress", "graphopt")

graph_top_gpt4 <- make_codiagnosis_graph(df_codiag_gpt4, n_diagnoses = top_n)

for (l in layouts){
  set.seed(seed)
  plt <- centrality_graph(graph_top_gpt4, layout = l)
  plt <- plt + ggtitle("GPT4", subtitle = sprintf("Layout %s", l))
  print(plt)
}

```
```{r, fig.width=8, fig.height=6, warning=F, message=F}
top_n <-  200
seed <- 321
layout <- "stress"

graph_top_gpt3 <- make_codiagnosis_graph(df_codiag_gpt3, n_diagnoses = top_n)
graph_top_gpt4 <- make_codiagnosis_graph(df_codiag_gpt4, n_diagnoses = top_n)
graph_top_gpt4_icd <- make_codiagnosis_graph(df_codiag_gpt4_icd, n_diagnoses = top_n)

set.seed(seed);plt_graph_gpt3 <- centrality_graph(graph_top_gpt3, layout = layout); plt_graph_gpt3 + ggtitle("GPT3", subtitle = sprintf("Top %s", top_n))
set.seed(seed);plt_graph_gpt4 <- centrality_graph(graph_top_gpt4, layout = layout); plt_graph_gpt4 + ggtitle("GPT4", subtitle = sprintf("Top %s", top_n))
set.seed(seed);plt_graph_gpt4icd <- centrality_graph(graph_top_gpt4_icd, layout = layout); plt_graph_gpt4icd + ggtitle("GPT4 ICD", subtitle = sprintf("Top %s", top_n))
```
# Evaluate edge density

- Edge density represents the total number of edges in a graph relative to the total number of **possible** edges in the graph
  - When all possible edges are present, edge density = 1
  - When no edges are present, edge density = 0
- Dense co-occurrence networks represent criteria that generate highly reproducible diagnoses. A sparse co-occurrence represents a high degree of variability 


```{r, eval=F}
# Run in script scripts/network_analysis/edge_density_ci.R
boot_graph_ci <- function(g, B, seed=NULL){
  if (!is.null(seed)){set.seed(seed)}
  g <- as_adjacency_matrix(g)  
  g <- as.matrix(g) 
  g <- snowboot::vertboot(g, boot_rep = B)
  g <- sapply(1:B, function(x) edge_density(graph_from_adjacency_matrix(g[[x]])))
  quantile(g, c(0.025, 0.5, 0.975))
}

# Calculate edge density 95% CI for each criteria
edge_density_boot <- function(df, replications = 100, seed = 1234){
  df_density <- df %>%
    ungroup() %>%
    select(criteria, from, to, weight = n, rank) %>%
    group_by(criteria) %>%
    nest() %>%
    mutate(boot = map(data, function(g){
      g <-  graph_from_data_frame(g, directed = F)
      out <- boot_graph_ci(g, B=replications, seed=seed)
      out["edge_density"] = edge_density(g)
      out
    })) %>%
    select(-data) %>%
    unnest_wider(boot)
  return(df_density)
}

edge_density_boot(df_codiag_gpt4, replications = 1000)
```

```{r}
edge_density_plot <- function(df){
  df %>% 
    format_criteria() %>% 
    ggplot(aes(x = criteria))+
    geom_point(aes(y=edge_density), color = "black")+
    geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.4)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x="", y="Edge density")
}
```
```{r, fig.width=2, fig.height=4, message = F}
models <- c("gpt3", "gpt4", "gpt4_icd")

for (m in models){
  path <- sprintf("data/network_analysis/edge_density_boot_%s.csv", m)
  print(path)
  plt <- read_csv(here(path)) %>% 
    edge_density_plot()+
    ggtitle(m)
  print(plt)
}

```

### Permutation testing of edge density significance
```{r, eval = F}
# Run in separate script source(here("scripts/network_analysis/edge_density_permutation.R"))
library(here)
source(here("utils/data_processing.R"))
source(here("utils/figures.R"))
library(future.apply)

threads <- 48
n_boot <- 500
model <- "gpt4"

read_path <- sprintf("data/processed_diagnoses/diagnoses_%s.csv.gz", model)
df <- read_csv(here(read_path))
df_codiag <- create_codiagnosis_df(df)

df_density <- df_codiag %>%
  ungroup() %>%
  select(criteria, from, to, weight = n, rank) %>%
  group_by(criteria) %>%
  nest() %>%
  mutate(data = map_dbl(data, function(g){
    g <-  graph_from_data_frame(g, directed = F)
    edge_density(g)
  })) %>% 
  deframe()


difference_dist <- function(x){
  d <- dist(x, method = "manhattan")
  v <- as.dist(apply(combn(x, 2, simplify = T), 2, diff))
  d[1:length(v)] <- v
  broom::tidy(d)
}

criteria_levels <- c(
  "eular_acr_sle",
  "slicc_sle",
  "mcas_consortium",
  "mcas_alternative"
)

graph_permutation_diff <- function(){
  t(combn(c(
    "eular_acr_sle",
    "mcas_alternative",
    "mcas_consortium",
    "slicc_sle"),
    2)) %>% 
    as.data.frame() %>% 
    mutate(data = map2(V1, V2, function(x,y){
      filter(df, criteria == x | criteria == y) %>% 
        mutate(diagnosis = sample(diagnosis, replace = F)) %>% 
        create_codiagnosis_df()
    })) %>% 
    mutate(data = map_dbl(data, function(d){
      ungroup(d) %>%
        select(criteria, from, to, weight = n, rank) %>% 
        nest(.by = criteria) %>% 
        mutate(data = map_dbl(data, ~edge_density(graph_from_data_frame(.)))) %>% 
        deframe() %>% diff()
    })) %>% 
    unite(comparison, V1, V2, sep = "__") %>% 
    deframe()
}


plan(multisession, workers = threads)
permutation_data <- future_replicate(n = n_boot, graph_permutation_diff(), future.seed = 1234)

permutation_data <- as.data.frame(permutation_data) %>% 
  rownames_to_column("pair") %>% 
  separate(pair, into = c("item1", "item2"), sep = "__") %>% 
  mutate(data = map2(item1, item2, ~sort(factor(c(.x,.y), levels = criteria_levels)))) %>% 
  unnest_wider(data, names_sep = "") %>% 
  mutate(reverse = item1 != data1) %>% 
  unite(pair, data1, data2, sep = "__") %>% 
  select(!contains("item")) %>% 
  pivot_longer(!c(pair, reverse), names_to = "i", values_to = "difference") %>% 
  mutate(difference = ifelse(reverse, -difference, difference)) %>% 
  select(-reverse)

original_data <- difference_dist(df_density) %>% 
  rename(difference = distance) %>% 
  mutate_at(vars(c(item1, item2)), as.character) %>% 
  mutate(data = map2(item1, item2, ~sort(factor(c(.x,.y), levels = criteria_levels)))) %>% 
  unnest_wider(data, names_sep = "") %>% 
  mutate(reverse = item1 != data1) %>% 
  mutate(difference = ifelse(reverse, -difference, difference)) %>% 
  unite(pair, data1, data2, sep = "__") %>% 
  select(pair, difference)

permutation_plot_raw <- ggplot(permutation_data, aes(x = difference))+
  geom_histogram()+
  geom_vline(data = original_data, aes(xintercept = difference))+
  facet_wrap(~pair)+
  theme_bw()

permutation_plot_abs <- ggplot(permutation_data, aes(x = abs(difference)))+
  geom_histogram()+
  geom_vline(data = original_data, aes(xintercept = abs(difference)))+
  facet_wrap(~pair)+
  theme_bw()

permutation_significance_abs <- permutation_data %>% 
  summarise(permutation = list(difference), .by = pair) %>% 
  left_join(original_data) %>% 
  mutate(
    abs_quantile = map2_dbl(difference, permutation, ~1-ecdf(abs(.y))(abs(.x)))
  ) %>% 
  select(pair, abs_quantile)

output_list <- list(
  "original_data" = original_data,
  "permutation_data" = permutation_data,
  "permutation_significance_abs" = permutation_significance_abs,
  "permutation_plot_raw" = permutation_plot_raw,
  "permutation_plot_abs" = permutation_plot_abs
)

write_path <- sprintf("data/network_analysis/edge_density_permutation_%s.RDS", model)
saveRDS(output_list, here(write_path))
```



```{r}
readRDS(here("data/network_analysis/edge_density_permutation_gpt4.RDS"))
```

- The observed difference in edge densities is greater that 95% of all randomly permuted differences (p < 0.05) for all but the comparison between the SLICC SLE criteria and the Consortium MCAS criteria

```{r, fig.width=2, fig.height=4, message=F}
# Combining permutation p-values with edge density mean-CI plot
edge_density_sig_plot <- function(ci_df, permutation_df=NULL){
  stat_test_template <- ci_df %>% 
    format_criteria() %>% 
    mutate(criteria = as.character(criteria)) %>% 
    pivot_longer(-criteria, names_to = "name", values_to = "edge_density") %>% 
    rstatix::t_test(edge_density ~ criteria) %>% 
    rstatix::add_xy_position() %>% 
    sort_paired_columns(prefix = "group")
  
  permutation_df <- permutation_df %>% 
    separate(pair, into = c("group1", "group2"), sep = "__") %>%
    rename(p = abs_quantile) %>% 
    mutate(index = 1:n()) %>% 
    pivot_longer(-c(p, index), names_to = "group", values_to = "criteria") %>% 
    format_criteria() %>% 
    pivot_wider(names_from = "group", values_from = "criteria") %>% 
    select(-index) %>% 
    sort_paired_columns(prefix = "group")
  
  stat_test <- stat_test_template %>% 
    select(-p, -p.adj, -p.adj.signif) %>%
    left_join(permutation_df, by = c("group1", "group2")) %>% 
    mutate(p.adj = p.adjust(p, method = "BH")) %>% 
    mutate(p.adj.signif = ifelse(p.adj <= 0.05, "*", "ns"))
  
  ci_df %>%
    format_criteria() %>%
    ggplot(aes(x = criteria))+
    geom_point(aes(y=edge_density), color = "black")+
    geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.4)+
    ggpubr::stat_pvalue_manual(data = stat_test, hide.ns = T)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(x="", y="Edge density")
}

plt_density_gpt4 <- edge_density_sig_plot(
  ci_df = read_csv(here("data/network_analysis/edge_density_boot_gpt4.csv")),
  permutation_df = readRDS(here("data/network_analysis/edge_density_permutation_gpt4.RDS")) %>% 
    .$permutation_significance_abs 
)

plt_density_gpt4
```

# Plot centrality
```{r}
calculate_subgraph_centrality <- function(g, centrality_fun = "centrality_eigen"){
  data.frame(criteria = g %>% activate(edges) %>% pull(criteria) %>% unique()) %>% 
    mutate(sub_graphs = map(criteria, function(c){
      g %>% as_data_frame() %>% filter(criteria == c) %>% as_tbl_graph(directed = F) %>% 
        activate(nodes) %>% mutate(centrality = get(centrality_fun)()) %>% data.frame()
    })) %>% 
  unnest(sub_graphs) %>% 
  pivot_wider(names_from = "name", values_from = "centrality", values_fill = 0) %>% 
  column_to_rownames("criteria")
}

graph_all_gpt4 <- make_codiagnosis_graph(df_codiag_gpt4, n_diagnoses = top_n)
df_centr_gpt4 <- calculate_subgraph_centrality(graph_all_gpt4)
```

```{r}
custom_heatmap <- function(data, title, metric, color_scale = hcl.colors(3, "Earth"), midpoint = NULL, symmetric = T, font_size=10){
  scale_max <- ifelse(symmetric,max(abs(data)),max(data))
  scale_min <- ifelse(symmetric,-max(abs(data)),min(data))
  scale_mid <- scale_min + (scale_max - scale_min)/2
  
  midpoint <- ifelse(is.null(midpoint), scale_mid, midpoint)
  
  color_function <-circlize::colorRamp2(c(scale_min,midpoint,scale_max), color_scale)
  
  ComplexHeatmap::Heatmap(
    data,
    col = color_function,
    rect_gp = grid::gpar(col = "black", lwd = 1),
    column_title = title,
    name = metric,
    row_names_gp = grid::gpar(fontsize = font_size),  # Adjust font size for row labels
    column_names_gp = grid::gpar(fontsize = font_size)
  )
}
```


```{r, fig.width=4, fig.height=3.5}
cp_font <- 9
plt_heat_all <- df_codiag_gpt4 %>% 
  make_codiagnosis_graph() %>% 
  calculate_subgraph_centrality() %>% 
  rownames_to_column("criteria") %>% 
  format_criteria() %>% 
  column_to_rownames("criteria") %>% 
  as.matrix() %>% 
  t() %>% 
  lsa::cosine() %>% 
  custom_heatmap(color_scale = viridis::viridis(3), title = " ", metric = "Cosine\nsimilarity", symmetric = F)
plt_heat_all

plt_heat_top <- df_centr_gpt4 %>% 
  rownames_to_column("criteria") %>% 
  format_criteria() %>% 
  column_to_rownames("criteria") %>% 
  as.matrix() %>% 
  t() %>% 
  lsa::cosine() %>% 
  custom_heatmap(color_scale = viridis::viridis(3), title = " ", metric = "Cosine\nsimilarity", symmetric = F,
                 font_size = 8
                 )
plt_heat_top
```
# Final plot

```{r, fig.width=5, fig.height=6.75}
set.seed(1234);plt_graph_gpt4 <- centrality_graph(
  graph_top_gpt4, 
  layout = "stress",
  point_size = 2, 
  border_size = 0.5,
  edge_width = 0.5,
  edge_alpha = 0.75)
plt_fig <- cowplot::plot_grid(
  cowplot::plot_grid(
    NULL, plt_graph_gpt4, nrow=1, rel_widths=c(0.05,0.9), labels = c("A","")
  ),
  NULL,
  cowplot::plot_grid(
    plt_density_gpt4,
    NULL,
    grid::grid.grabExpr(ComplexHeatmap::draw(plt_heat_all)),
    nrow = 1,
    rel_widths = c(0.3,0.05,0.7),
    labels = c("B","","C")
  ),

  ncol = 1,
  rel_heights = c(1,0.05,0.8)
)

plt_fig 
```
```{r}
ggsave(here("figures/5_Network_analysis.pdf"), plot=plt_fig, height = 6.75, width = 5)
```



