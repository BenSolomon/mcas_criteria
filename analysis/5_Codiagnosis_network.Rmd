---
title: "Co-diagnosis network analysis"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r, message = F}
source(here("utils/data_processing.R"))
source(here("utils/figures.R"))
```

# Introduction

- Goal is to model diagnoses from each criteria based on how frequently they co-occur together within a single 10-point differential diagnosis iteration.
- The rationale is that an ideal set of criteria will tend to result in a relatively similar set of diagnoses in each iteration and thus a small set of highly co-occurring diagnoses.
- Conversely, a poor set of criteria will generate highly variable diagnoses in each iteration and rates of co-occurrence will be comparatively lower.

# Import and process data
```{r, message=F}
# Original outputs
df_gpt3.5 <- read_csv(here("data/processed_diagnoses/diagnoses_gpt3.csv.gz"))
df_gpt4.0 <- read_csv(here("data/processed_diagnoses/diagnoses_gpt4.csv.gz"))
df_claude3_haiku_t1.0 <- read_csv(here("data/processed_diagnoses/diagnoses_claude3_haiku_t1.0.csv.gz"))
df_claude3_haiku_t0.1 <- read_csv(here("data/processed_diagnoses/diagnoses_claude3_haiku_t0.1.csv.gz"))
df_claude3_opus_t1.0 <- read_csv(here("data/processed_diagnoses/diagnoses_claude3_opus_t1.0.csv.gz"))
df_gemini1.0_pro_t1.0 <- read_csv(here("data/processed_diagnoses/diagnoses_gemini1.0_pro_t1.0.csv.gz"))
df_gemini1.5_flash_t1.0 <- read_csv(here("data/processed_diagnoses/diagnoses_gemini1.0_pro_t1.0.csv.gz"))
```

```{r, message = F}
# ICD mapped outputs
#TODO Find source of NAs 
#TODO drop index column in processing script
df_gpt3.5_icd <- read_csv(here("data/processed_diagnoses/diagnoses_gpt3.5_icd.csv.gz")) %>% drop_na() %>% select(-index)
df_gpt4.0_icd <- read_csv(here("data/processed_diagnoses/diagnoses_gpt4_icd.csv.gz")) %>% drop_na() %>% select(-index)
df_claude3_haiku_t1.0_icd <- read_csv(here("data/processed_diagnoses/diagnoses_claude3_haiku_t1.0_icd.csv.gz")) %>% drop_na() %>% select(-index)
df_claude3_opus_t1.0_icd <- read_csv(here("data/processed_diagnoses/diagnoses_claude3_opus_t1.0_icd.csv.gz")) %>% drop_na() %>% select(-index)
df_gemini1.0_pro_t1.0_icd <- read_csv(here("data/processed_diagnoses/diagnoses_gemini1.0_pro_t1.0_icd.csv.gz")) %>% drop_na() %>% select(-index)
```

```{r}
# Tally each pair of co-occuring diagnoses within each criteria
# Original responses
df_gpt3.5_codiag <- create_codiagnosis_df(df_gpt3.5, remove_singletons = T)
df_gpt4.0_codiag <- create_codiagnosis_df(df_gpt4.0, remove_singletons = T)
df_claude3_haiku_t1.0_codiag <- create_codiagnosis_df(df_claude3_haiku_t1.0, remove_singletons = T)
df_claude3_opus_t1.0_codiag <- create_codiagnosis_df(df_claude3_opus_t1.0, remove_singletons = T)
df_gemini1.0_pro_t1.0_codiag <- create_codiagnosis_df(df_gemini1.0_pro_t1.0, remove_singletons = T)
```


```{r}
# ICD converted responses
df_gpt3.5_icd_codiag <- create_codiagnosis_df(df_gpt3.5_icd, remove_singletons = T)
df_gpt4.0_icd_codiag <- create_codiagnosis_df(df_gpt4.0_icd, remove_singletons = T)
df_claude3_haiku_t1.0_icd_codiag <- create_codiagnosis_df(df_claude3_haiku_t1.0_icd, remove_singletons = T)
df_claude3_opus_t1.0_icd_codiag <- create_codiagnosis_df(df_claude3_opus_t1.0_icd, remove_singletons = T)
df_gemini1.0_pro_t1.0_icd_codiag <- create_codiagnosis_df(df_gemini1.0_pro_t1.0_icd, remove_singletons = T)
```


```{r}
df_gpt4.0_codiag
```

# Graph visualization

## Exploring layouts 

- To determine clearest visualization of nodes and edges

```{r, fig.width=8, fig.height=6, warning=F, message=F}
# Selecting a layout
top_n <-  200
seed <- 1234

layouts <- c("fr", "dh", "kk", "stress", "graphopt")

graph_top_gpt4 <- make_codiagnosis_graph(df_gpt4.0_codiag, n_diagnoses = top_n)

for (l in layouts){
  set.seed(seed)
  plt <- centrality_graph(graph_top_gpt4, layout = l)
  plt <- plt + ggtitle("GPT4", subtitle = sprintf("Layout %s", l))
  print(plt)
}

```
## Individual model data

### Original responses

```{r, fig.width=8, fig.height=6, warning=F, message=F}
top_n <-  200
seed <- 321
graph_layout <- "stress"

codiag_graph_wrapper <- function(data){
  set.seed(seed)
  data <- make_codiagnosis_graph(data, n_diagnoses = top_n)
  centrality_graph(data, layout = graph_layout)
}

codiag_graph_wrapper(df_gpt3.5_codiag)+ ggtitle("ChatGPT 3.5", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_gpt4.0_codiag)+ ggtitle("ChatGPT 4.0", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_claude3_haiku_t1.0_codiag)+ ggtitle("Claude 3 Haiku", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_claude3_opus_t1.0_codiag)+ ggtitle("Claude 3 Opus", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_gemini1.0_pro_t1.0_codiag)+ ggtitle("Gemini 1.0 Pro", subtitle = sprintf("Top %s", top_n))
```
### ICD converted respones

```{r, fig.width=8, fig.height=6, warning=F, message=F}
codiag_graph_wrapper(df_gpt3.5_icd_codiag)+ ggtitle("ChatGPT 3.5 ICD", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_gpt4.0_icd_codiag)+ ggtitle("ChatGPT 4.0 ICD", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_claude3_haiku_t1.0_icd_codiag)+ ggtitle("Claude 3 Haiku ICD", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_claude3_opus_t1.0_icd_codiag)+ ggtitle("Claude 3 Opus ICD", subtitle = sprintf("Top %s", top_n))
codiag_graph_wrapper(df_gemini1.0_pro_t1.0_icd_codiag)+ ggtitle("Gemini 1.0 Pro ICD", subtitle = sprintf("Top %s", top_n))
```

## Combined model data

### Original responses

```{r, fig.width=8, fig.height=6, warning=F, message=F}
set.seed(seed)
multi_make_codiagnosis_graph(threshold_method = "individual", top_n = 200, layout="stress",
                             df_gpt3.5_codiag, df_gpt4.0_codiag, 
                             df_claude3_haiku_t1.0_codiag, df_claude3_opus_t1.0_codiag,
                             df_gemini1.0_pro_t1.0_codiag)
```

```{r, fig.width=8, fig.height=6, warning=F, message=F}
multi_make_codiagnosis_graph(threshold_method = "average", top_n = 200, layout="stress",
                             df_gpt3.5_codiag, df_gpt4.0_codiag, 
                             df_claude3_haiku_t1.0_codiag, df_claude3_opus_t1.0_codiag,
                             df_gemini1.0_pro_t1.0_codiag)
```
### ICD converted responses

```{r, fig.width=8, fig.height=6, warning=F, message=F}
set.seed(seed)
multi_make_codiagnosis_graph(threshold_method = "individual", top_n = 200, layout="stress",
                             df_gpt3.5_icd_codiag, df_gpt4.0_icd_codiag, 
                             df_claude3_haiku_t1.0_icd_codiag, df_claude3_opus_t1.0_icd_codiag,
                             df_gemini1.0_pro_t1.0_icd_codiag)
```


```{r, fig.width=8, fig.height=6, warning=F, message=F}
multi_make_codiagnosis_graph(threshold_method = "average", top_n = 200, layout="stress",
                             df_gpt3.5_icd_codiag, df_gpt4.0_icd_codiag, 
                             df_claude3_haiku_t1.0_icd_codiag, df_claude3_opus_t1.0_icd_codiag,
                             df_gemini1.0_pro_t1.0_icd_codiag)
```

# Evaluate edge density

- Edge density represents the total number of edges in a graph relative to the total number of **possible** edges in the graph
  - When all possible edges are present, edge density = 1
  - When no edges are present, edge density = 0
- Dense co-occurrence networks represent criteria that generate highly reproducible diagnoses. A sparse co-occurrence represents a high degree of variability 

## Combined model data

### Original responses

```{r, fig.width=4, fig.height=3.5}
multi_edge_density_plot(df_gpt3.5_codiag, df_gpt4.0_codiag, df_claude3_haiku_t1.0_codiag,
                        df_claude3_opus_t1.0_codiag, df_gemini1.0_pro_t1.0_codiag)  

```

### ICD converted responses

```{r, fig.width=4, fig.height=3.5}
multi_edge_density_plot(df_gpt3.5_icd_codiag, df_gpt4.0_icd_codiag, df_claude3_haiku_t1.0_icd_codiag,
                        df_claude3_opus_t1.0_icd_codiag, df_gemini1.0_pro_t1.0_icd_codiag)  

```


## Bootstrapping individual model
```{r, eval=F}
# Run in script scripts/network_analysis/edge_density_ci.R
boot_graph_ci <- function(g, B, seed=NULL){
  if (!is.null(seed)){set.seed(seed)}
  g <- as_adjacency_matrix(g)  
  g <- as.matrix(g) 
  g <- snowboot::vertboot(g, boot_rep = B)
  g <- sapply(1:B, function(x) edge_density(graph_from_adjacency_matrix(g[[x]])))
  quantile(g, c(0.025, 0.5, 0.975))
}

# Calculate edge density 95% CI for each criteria
edge_density_boot <- function(df, replications = 100, seed = 1234){
  df_density <- df %>%
    ungroup() %>%
    select(criteria, from, to, weight = n, rank) %>%
    group_by(criteria) %>%
    nest() %>%
    mutate(boot = map(data, function(g){
      g <-  graph_from_data_frame(g, directed = F)
      out <- boot_graph_ci(g, B=replications, seed=seed)
      out["edge_density"] = edge_density(g)
      out
    })) %>%
    select(-data) %>%
    unnest_wider(boot)
  return(df_density)
}

edge_density_boot(df_gpt4.0_codiag, replications = 1000)
```

```{r}
edge_density_plot <- function(df){
  df %>% 
    format_criteria() %>% 
    ggplot(aes(x = criteria))+
    geom_point(aes(y=edge_density), color = "black")+
    geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.4)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x="", y="Edge density")
}
```
```{r, fig.width=2, fig.height=4, message = F}
models <- c("gpt3", "gpt4", "gpt4_icd")

for (m in models){
  path <- sprintf("data/network_analysis/edge_density_boot_%s.csv", m)
  print(path)
  plt <- read_csv(here(path)) %>% 
    edge_density_plot()+
    ggtitle(m)
  print(plt)
}

```

### Permutation testing of edge density significance
```{r, eval = F}
# Run in separate script source(here("scripts/network_analysis/edge_density_permutation.R"))
library(here)
source(here("utils/data_processing.R"))
source(here("utils/figures.R"))
library(future.apply)

threads <- 48
n_boot <- 500
model <- "gpt4"

read_path <- sprintf("data/processed_diagnoses/diagnoses_%s.csv.gz", model)
df <- read_csv(here(read_path))
df_codiag <- create_codiagnosis_df(df)

df_density <- df_codiag %>%
  ungroup() %>%
  select(criteria, from, to, weight = n, rank) %>%
  group_by(criteria) %>%
  nest() %>%
  mutate(data = map_dbl(data, function(g){
    g <-  graph_from_data_frame(g, directed = F)
    edge_density(g)
  })) %>% 
  deframe()


difference_dist <- function(x){
  d <- dist(x, method = "manhattan")
  v <- as.dist(apply(combn(x, 2, simplify = T), 2, diff))
  d[1:length(v)] <- v
  broom::tidy(d)
}

criteria_levels <- c(
  "eular_acr_sle",
  "slicc_sle",
  "mcas_consortium",
  "mcas_alternative"
)

graph_permutation_diff <- function(){
  t(combn(c(
    "eular_acr_sle",
    "mcas_alternative",
    "mcas_consortium",
    "slicc_sle"),
    2)) %>% 
    as.data.frame() %>% 
    mutate(data = map2(V1, V2, function(x,y){
      filter(df, criteria == x | criteria == y) %>% 
        mutate(diagnosis = sample(diagnosis, replace = F)) %>% 
        create_codiagnosis_df()
    })) %>% 
    mutate(data = map_dbl(data, function(d){
      ungroup(d) %>%
        select(criteria, from, to, weight = n, rank) %>% 
        nest(.by = criteria) %>% 
        mutate(data = map_dbl(data, ~edge_density(graph_from_data_frame(.)))) %>% 
        deframe() %>% diff()
    })) %>% 
    unite(comparison, V1, V2, sep = "__") %>% 
    deframe()
}


plan(multisession, workers = threads)
permutation_data <- future_replicate(n = n_boot, graph_permutation_diff(), future.seed = 1234)

permutation_data <- as.data.frame(permutation_data) %>% 
  rownames_to_column("pair") %>% 
  separate(pair, into = c("item1", "item2"), sep = "__") %>% 
  mutate(data = map2(item1, item2, ~sort(factor(c(.x,.y), levels = criteria_levels)))) %>% 
  unnest_wider(data, names_sep = "") %>% 
  mutate(reverse = item1 != data1) %>% 
  unite(pair, data1, data2, sep = "__") %>% 
  select(!contains("item")) %>% 
  pivot_longer(!c(pair, reverse), names_to = "i", values_to = "difference") %>% 
  mutate(difference = ifelse(reverse, -difference, difference)) %>% 
  select(-reverse)

original_data <- difference_dist(df_density) %>% 
  rename(difference = distance) %>% 
  mutate_at(vars(c(item1, item2)), as.character) %>% 
  mutate(data = map2(item1, item2, ~sort(factor(c(.x,.y), levels = criteria_levels)))) %>% 
  unnest_wider(data, names_sep = "") %>% 
  mutate(reverse = item1 != data1) %>% 
  mutate(difference = ifelse(reverse, -difference, difference)) %>% 
  unite(pair, data1, data2, sep = "__") %>% 
  select(pair, difference)

permutation_plot_raw <- ggplot(permutation_data, aes(x = difference))+
  geom_histogram()+
  geom_vline(data = original_data, aes(xintercept = difference))+
  facet_wrap(~pair)+
  theme_bw()

permutation_plot_abs <- ggplot(permutation_data, aes(x = abs(difference)))+
  geom_histogram()+
  geom_vline(data = original_data, aes(xintercept = abs(difference)))+
  facet_wrap(~pair)+
  theme_bw()

permutation_significance_abs <- permutation_data %>% 
  summarise(permutation = list(difference), .by = pair) %>% 
  left_join(original_data) %>% 
  mutate(
    abs_quantile = map2_dbl(difference, permutation, ~1-ecdf(abs(.y))(abs(.x)))
  ) %>% 
  select(pair, abs_quantile)

output_list <- list(
  "original_data" = original_data,
  "permutation_data" = permutation_data,
  "permutation_significance_abs" = permutation_significance_abs,
  "permutation_plot_raw" = permutation_plot_raw,
  "permutation_plot_abs" = permutation_plot_abs
)

write_path <- sprintf("data/network_analysis/edge_density_permutation_%s.RDS", model)
saveRDS(output_list, here(write_path))
```



```{r}
readRDS(here("data/network_analysis/edge_density_permutation_gpt4.RDS"))
```

- The observed difference in edge densities is greater that 95% of all randomly permuted differences (p < 0.05) for all but the comparison between the SLICC SLE criteria and the Consortium MCAS criteria

```{r, fig.width=2, fig.height=4, message=F}
# Combining permutation p-values with edge density mean-CI plot
edge_density_sig_plot <- function(ci_df, permutation_df=NULL){
  stat_test_template <- ci_df %>% 
    format_criteria() %>% 
    mutate(criteria = as.character(criteria)) %>% 
    pivot_longer(-criteria, names_to = "name", values_to = "edge_density") %>% 
    rstatix::t_test(edge_density ~ criteria) %>% 
    rstatix::add_xy_position() %>% 
    sort_paired_columns(prefix = "group")
  
  permutation_df <- permutation_df %>% 
    separate(pair, into = c("group1", "group2"), sep = "__") %>%
    rename(p = abs_quantile) %>% 
    mutate(index = 1:n()) %>% 
    pivot_longer(-c(p, index), names_to = "group", values_to = "criteria") %>% 
    format_criteria() %>% 
    pivot_wider(names_from = "group", values_from = "criteria") %>% 
    select(-index) %>% 
    sort_paired_columns(prefix = "group")
  
  stat_test <- stat_test_template %>% 
    select(-p, -p.adj, -p.adj.signif) %>%
    left_join(permutation_df, by = c("group1", "group2")) %>% 
    mutate(p.adj = p.adjust(p, method = "BH")) %>% 
    mutate(p.adj.signif = ifelse(p.adj <= 0.05, "*", "ns"))
  
  ci_df %>%
    format_criteria() %>%
    ggplot(aes(x = criteria))+
    geom_point(aes(y=edge_density), color = "black")+
    geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.4)+
    ggpubr::stat_pvalue_manual(data = stat_test, hide.ns = T)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(x="", y="Edge density")
}

plt_density_gpt4 <- edge_density_sig_plot(
  ci_df = read_csv(here("data/network_analysis/edge_density_boot_gpt4.csv")),
  permutation_df = readRDS(here("data/network_analysis/edge_density_permutation_gpt4.RDS")) %>% 
    .$permutation_significance_abs 
)

plt_density_gpt4
```

# Plot centrality
```{r}
calculate_subgraph_centrality <- function(g, centrality_fun = "centrality_eigen"){
  data.frame(criteria = g %>% activate(edges) %>% pull(criteria) %>% unique()) %>% 
    mutate(sub_graphs = map(criteria, function(c){
      g %>% as_data_frame() %>% filter(criteria == c) %>% as_tbl_graph(directed = F) %>% 
        activate(nodes) %>% mutate(centrality = get(centrality_fun)()) %>% data.frame()
    })) %>% 
  unnest(sub_graphs) %>% 
  pivot_wider(names_from = "name", values_from = "centrality", values_fill = 0) %>% 
  column_to_rownames("criteria")
}

graph_all_gpt4 <- make_codiagnosis_graph(df_gpt4.0_codiag, n_diagnoses = top_n)
df_centr_gpt4 <- calculate_subgraph_centrality(graph_all_gpt4)
```

```{r}
centrality_similarity <- function(data){
  data %>% 
    rownames_to_column("criteria") %>% 
    format_criteria() %>% 
    column_to_rownames("criteria") %>% 
    as.matrix() %>% 
    t() %>% 
    lsa::cosine() %>% 
    as.data.frame() %>% 
    rownames_to_column("V1") %>% 
    pivot_longer(-V1, names_to = "V2", values_to = "cosine")
}

centrality_similarity(df_centr_gpt4)
```
```{r}
centrality_wrapper <- function(data){
  make_codiagnosis_graph(data, n_diagnoses = 200) %>% 
    calculate_subgraph_centrality() %>% 
    centrality_similarity()
}

listN(df_gpt3.5_icd_codiag, df_gpt4.0_icd_codiag, df_claude3_haiku_t1.0_icd_codiag,
                        df_claude3_opus_t1.0_icd_codiag, df_gemini1.0_pro_t1.0_icd_codiag) %>% 
  enframe(name = "model", value = "data") %>% 
  mutate(data = map(data, centrality_wrapper)) %>% 
  unnest(data) %>% 
  summarise(cosine = mean(cosine), .by = c("V1", "V2")) %>% 
  pivot_wider(names_from = "V2", values_from = "cosine") %>% 
  column_to_rownames("V1") %>% 
  as.matrix() %>% 
  ComplexHeatmap::Heatmap()
```
```{r}
centrality_wrapper <- function(data){
  # make_codiagnosis_graph(data, n_diagnoses = 200) %>% 
  make_codiagnosis_graph(data) %>% 
    calculate_subgraph_centrality()
  # %>% 
    # centrality_similarity()
}

cosine_data <- listN(df_gpt3.5_icd_codiag, df_gpt4.0_icd_codiag, df_claude3_haiku_t1.0_icd_codiag,
                        df_claude3_opus_t1.0_icd_codiag, df_gemini1.0_pro_t1.0_icd_codiag) %>% 
  enframe(name = "model", value = "data") %>% 
  mutate(data = map(data, ~centrality_wrapper(.) %>% rownames_to_column("criteria"))) %>% 
  unnest(data) %>% 
  mutate_all(~replace_na(., 0)) %>% 
  unite(sample, model, criteria, sep = "_") %>% 
  column_to_rownames("sample") %>% 
  t() %>% 
  lsa::cosine()

ComplexHeatmap::Heatmap(cosine_data)
```
```{r, fig.width=5.5, fig.height=3.5}
custom_heatmap2 <- function(data, 
                           title, 
                           metric, 
                           color_scale = hcl.colors(3, "Earth"), 
                           midpoint = NULL, 
                           symmetric = T, 
                           font_size=10,
                           dendrogram_weight = unit(10, "mm"),
                           legend_params = list(NULL)){
  scale_max <- ifelse(symmetric,max(abs(data)),max(data))
  scale_min <- ifelse(symmetric,-max(abs(data)),min(data))
  scale_mid <- scale_min + (scale_max - scale_min)/2
  
  midpoint <- ifelse(is.null(midpoint), scale_mid, midpoint)
  
  color_function <-circlize::colorRamp2(c(scale_min,midpoint,scale_max), color_scale)
  
  # legend_params <- append(
  #   list(
  #     title_gp = grid::gpar(fontsize = font_size),
  #     labels_gp = grid::gpar(fontsize = font_size*0.8)), 
  #   legend_params)
  

  annotation_data <- data.frame(
  rownames = rownames(cosine_data),
  model = str_extract(rownames(cosine_data), "gpt3.5|gpt4.0|claude3_haiku|claude3_opus|gemini1.0_pro"),
  criteria = str_extract(rownames(cosine_data), "slicc_sle|eular_acr_sle|mcas_consortium|mcas_alternative")
) %>% 
  column_to_rownames("rownames") %>% 
  format_criteria() %>% 
  format_models()

  # model_colors <- brewer.pal(7, "Dark2")[-6]
  model_colors <- colorspace::lighten(brewer.pal(5, "Dark2"), amount = -0.1)
  names(model_colors) <- unique(annotation_data$model)
  
  criteria_colors <- colorspace::lighten(brewer.pal(4, "Set1"), amount = 0.3)
  names(criteria_colors) <- unique(annotation_data$criteria)
  
  col_annotation <- HeatmapAnnotation(
    Model = annotation_data$model,
    Criteria = annotation_data$criteria,
    col = list(Model = model_colors, Criteria = criteria_colors)
  )
  
  # Heatmap(
  #   data,
  #   name = "Distance",
  #   top_annotation = col_annotation,
  #   rect_gp = grid::gpar(col = "black", lwd = 1),
  #   show_row_names = FALSE,
  #   show_column_names = FALSE,
  #   cluster_columns = TRUE,
  #   cluster_rows = TRUE,
  #   col = circlize::colorRamp2(c(min(distance_matrix), max(distance_matrix)), c("white", "red"))
  # )
  
  ComplexHeatmap::Heatmap(
    data,
    col = color_function,
    top_annotation = col_annotation,
    show_row_names = FALSE,
    show_column_names = FALSE,
    cluster_columns = TRUE,
    cluster_rows = TRUE,
    
    # rect_gp = grid::gpar(col = "black", lwd = 1),
    column_title = title,
    name = metric,
    # row_names_gp = grid::gpar(fontsize = font_size), 
    # column_names_gp = grid::gpar(fontsize = font_size),
    column_dend_height  = dendrogram_weight,
    row_dend_width = dendrogram_weight,
    # heatmap_legend_param = legend_params
  )
  
}
  
custom_heatmap2(cosine_data, 
                color_scale = viridis::viridis(3), 
                title = " ", 
                metric = "Cosine\nsimilarity", 
                symmetric = F,
                font_size = 8)  
  


```

```{r}
custom_heatmap <- function(data, 
                           title, 
                           metric, 
                           color_scale = hcl.colors(3, "Earth"), 
                           midpoint = NULL, 
                           symmetric = T, 
                           font_size=10,
                           dendrogram_weight = unit(10, "mm"),
                           legend_params = list(NULL)){
  scale_max <- ifelse(symmetric,max(abs(data)),max(data))
  scale_min <- ifelse(symmetric,-max(abs(data)),min(data))
  scale_mid <- scale_min + (scale_max - scale_min)/2
  
  midpoint <- ifelse(is.null(midpoint), scale_mid, midpoint)
  
  color_function <-circlize::colorRamp2(c(scale_min,midpoint,scale_max), color_scale)
  
  legend_params <- append(
    list(
      title_gp = grid::gpar(fontsize = font_size),
      labels_gp = grid::gpar(fontsize = font_size*0.8)), 
    legend_params)
  
  ComplexHeatmap::Heatmap(
    data,
    col = color_function,
    rect_gp = grid::gpar(col = "black", lwd = 1),
    column_title = title,
    name = metric,
    row_names_gp = grid::gpar(fontsize = font_size), 
    column_names_gp = grid::gpar(fontsize = font_size),
    column_dend_height  = dendrogram_weight,
    row_dend_width = dendrogram_weight,
    heatmap_legend_param = legend_params
  )
}
```

```{r}
plt_heat_all %>% ComplexHeatmap::Heatmap()
```


```{r, fig.width=4, fig.height=3.5}
cp_font <- 9
plt_heat_all <- df_gpt4.0_codiag %>% 
  make_codiagnosis_graph() %>% 
  calculate_subgraph_centrality() %>% 
  rownames_to_column("criteria") %>% 
  format_criteria() %>% 
  column_to_rownames("criteria") %>% 
  as.matrix() %>% 
  t() %>% 
  lsa::cosine() %>% 
  custom_heatmap(color_scale = viridis::viridis(3), title = " ", metric = "Cosine\nsimilarity", symmetric = F)
plt_heat_all

plt_heat_top <- df_centr_gpt4 %>% 
  rownames_to_column("criteria") %>% 
  format_criteria() %>% 
  column_to_rownames("criteria") %>% 
  as.matrix() %>% 
  t() %>% 
  lsa::cosine() %>% 
  custom_heatmap(color_scale = viridis::viridis(3), title = " ", metric = "Cosine\nsimilarity", symmetric = F,
                 font_size = 8
                 )
plt_heat_top
```
# Final plot

```{r, fig.width=5, fig.height=6.75}
set.seed(1234);plt_graph_gpt4 <- centrality_graph(
  graph_top_gpt4, 
  layout = "stress",
  point_size = 2, 
  border_size = 0.5,
  edge_width = 0.5,
  edge_alpha = 0.75)


plt_fig <- cowplot::plot_grid(
  cowplot::plot_grid(
    NULL, plt_graph_gpt4, nrow=1, rel_widths=c(0.05,0.9), labels = c("A","")
  ),
  NULL,
  cowplot::plot_grid(
    plt_density_gpt4,
    NULL,
    grid::grid.grabExpr(ComplexHeatmap::draw(plt_heat_all)),
    nrow = 1,
    rel_widths = c(0.3,0.05,0.7),
    labels = c("B","","C")
  ),

  ncol = 1,
  rel_heights = c(1,0.05,0.8)
)

plt_fig 
```

```{r, fig.width=3.5, fig.height=6}
set.seed(1234);plt_graph_gpt4 <- centrality_graph(
  graph_top_gpt4, 
  layout = "stress",
  point_size = 1.25, 
  border_size = 0.25,
  edge_width = 0.5,
  edge_alpha = 0.5, 
  label_text_size = 9,
  tick_text_size = 6,
  highlight_stroke_multiplier = 3,
  legend_height = unit(35, "pt"),
  legend_width = unit(10, "pt")) 

plt_density_gpt4 <- edge_density_sig_plot(
  ci_df = read_csv(here("data/network_analysis/edge_density_boot_gpt4.csv")),
  permutation_df = readRDS(here("data/network_analysis/edge_density_permutation_gpt4.RDS")) %>% 
    .$permutation_significance_abs 
) + theme(
  axis.text.y = element_text(size=7), 
  axis.title.y = element_text(size=9))

plt_heat_all <- df_gpt4.0_codiag %>% 
  make_codiagnosis_graph() %>% 
  calculate_subgraph_centrality() %>% 
  rownames_to_column("criteria") %>% 
  format_criteria() %>% 
  column_to_rownames("criteria") %>% 
  as.matrix() %>% 
  t() %>% 
  lsa::cosine() %>% 
  custom_heatmap(color_scale = viridis::viridis(3), 
                 title = " ", 
                 metric = "Cosine similarity", 
                 symmetric = F, 
                 font_size = 8,
                 dendrogram_weight = unit(3, "mm"),
                 legend_params = list(
    legend_height = unit(5, 'cm'),
    direction = "horizontal"
  ))


plt_fig <- cowplot::plot_grid(
  NULL, 
  cowplot::plot_grid(
    NULL, plt_graph_gpt4, nrow=1, rel_widths=c(0.05,0.9)
  ),
  NULL,
  cowplot::plot_grid(
    plot_grid(NULL, plt_density_gpt4 ,rel_heights = c(0.1, 1), ncol = 1),
    NULL,
    grid::grid.grabExpr(ComplexHeatmap::draw(plt_heat_all, heatmap_legend_side = "bottom")),
    nrow = 1,
    rel_widths = c(0.4,0.05,0.7),
    labels = c("B","","C"),
    axis = 'h', align = 'bt'
  ),

  ncol = 1,
  rel_heights = c(0.05, 1, 0.01, 1),
  labels = c("A")
)

plt_fig 
```


```{r}
ggsave(here("figures/5_Network_analysis.pdf"), plot=plt_fig, height = 6, width = 3.5)
```

