---
title: "Diagnostic criteria similarity based on ChatGPT embeddings"
output:
  html_notebook:
    toc: true
    toc_float: true
---
```{r, message = F}
library(tidyverse)
library(here)
source(here("utils/figures.R"))
```

# Introduction

- Transformer embeddings can be used to represent the contextual similarity of different character strings
- These embeddings often capture important relationships between strings based on the information they represent
- As such, these embeddings represent a way to measure the similarity of different symptoms or diagnoses based on how they were used in the large set of ChatGPT training data
- In order to evaluate how similar different MCAS criteria are based on the symptoms they include, these symptoms can be converted into ChatGPT embeddings and then the similarity of these embeddings can be quantified.


# Import data
```{r, message=F}
df_embeddings <- read_csv(here("data/symptom_chatgpt_embeddings_text-embedding-3-small.csv")) # Small ChatGPT embedding model
# df_embeddings <- read_csv(here("data/symptom_chatgpt_embeddings_text-embedding-3-large.csv")) # Large ChatGPT embedding model
df_embeddings <- df_embeddings %>% column_to_rownames("symptom")

df_embeddings[1:5,1:5]
```


```{r}
df_criteria <- tibble(criteria = list.files(here("data/disease_criteria"))) %>% 
  mutate(file = here(sprintf("data/disease_criteria/%s", criteria))) %>% 
  mutate(criteria = gsub("_criteria_symptoms\\.csv", "", criteria)) %>% 
  mutate(data = map(file, function(df){
    suppressMessages(read_csv(df)) %>% 
      mutate(feature = str_split(feature, ", "))
  })) 

df_criteria <- df_criteria %>% 
  format_criteria() %>% 
  select(-file) %>% 
  unnest(data) %>% 
  select(-system) %>% 
  unnest(feature)

df_criteria
```
```{r}
# Function to calculate centroids in multi-dimensional space
calculate_centroids <- function(df){
  df %>% 
    rownames_to_column("feature") %>% 
    right_join(df_criteria) %>% 
    nest(.by = criteria) %>% 
    mutate(data = map(data, function(df){
      df %>% 
        drop_na() %>% 
        distinct() %>% 
        column_to_rownames("feature") %>% 
        apply(MARGIN = 2, FUN = mean)
    })) %>% 
    unnest_wider(data) %>% 
    column_to_rownames("criteria")
}

# Function to switch between distances in a single line
custom_dist <- function(df, method = "euclidean"){
  if (method == "euclidean"){
    return(as.matrix(dist(df)))
  }
  if (method == "cosine"){
    return(lsa::cosine(t(as.matrix(df))))
  }
}
```


```{r, fig.width=4.5, fig.height=4, message = F}
# Plot heatmap of distance between centroids using full embeddings
as.data.frame(df_embeddings) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "euclidean") %>% 
  pheatmap::pheatmap(color = viridis::viridis(100, direction = -1), main = "Euclidean")

as.data.frame(df_embeddings) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "cosine") %>% 
  pheatmap::pheatmap(color = colorRampPalette(RColorBrewer::brewer.pal(11, "BrBG"))(101), main = "Cosine", breaks = seq(-1,1,length.out = 101))
```
- With full embedding space, cosine similarity doesn't have enough resolution. Likely because disease terms occupy a relatively similar reagion of the ChatGPT embedding space


# PCA analysis

- Instead of working with full embedding space, reduce variability via PCA

```{r}
pca_embedding <- prcomp(df_embeddings, scale. = T)
pca_embedding <- summary(pca_embedding)
```

```{r, fig.width=5, fig.height=4}
# Cumulative proportion of variance explained by component
pca_embedding$importance %>% t() %>% as.data.frame() %>% 
  rownames_to_column("component") %>% 
  mutate(component = as.numeric(str_extract(component, "[0-9]+"))) %>% 
  # ggplot(aes(x=component, y = `Proportion of Variance`)) +
  ggplot(aes(x=component, y = `Cumulative Proportion`)) +
  geom_path()+
  theme_bw()
```
- No clear set of PCA components to use for calculations. Supports using all components for distance calculations

### PCA Plot
```{r, fig.width=6, fig.height=4}
# Plot PCA reductions with criteria centroids
x <- "PC1"
y <- "PC2"

pca_embedding$x[,c(x,y)] %>% 
  as.data.frame() %>% 
  rownames_to_column("feature") %>% 
  left_join(df_criteria) %>% 
  drop_na() %>% 
  ggplot(aes(x=!!sym(x), y=!!sym(y), color = criteria))+
  geom_point(size = 0.5) +
  geom_point(data = . %>% group_by(criteria) %>% summarise_at(vars(contains("PC")), mean), size = 3, shape = 21, color = "black", aes(fill = criteria))+
  # stat_ellipse(size = 2, type = "t", level = 0.95)+
  # facet_wrap(~criteria) +
  theme_bw()+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")
```
- Using the two SLE criteria as a reference for similarity, plot demonstrates increased distance between the two MCAS criteria

### Mean distance plot
```{r}
symptom_distance_key_euc <- dist(pca_embedding$x) %>% 
  broom::tidy() %>% 
  mutate_at(vars(contains("item")), as.character) %>% 
  mutate(symptom_pair = map2(item1, item2, ~sort(c(.x,.y)))) %>% 
  unnest_wider(symptom_pair, names_sep = "") %>% 
  unite(symptom_pair, symptom_pair1, symptom_pair2, sep = " : ") %>% 
  select(symptom_pair, distance)

symptom_distance_key_euc
```
```{r}
df_compare_euc <- tribble(
  ~criteria1, ~criteria2,
  "SLE - EULAR-ACR", "SLE - SLICC",
  "MCAS - Consortium", "MCAS - Alternative"
  # "SLE - SLICC", "SLE - SLICC",
  # "MCAS - Consensus",  "MCAS - Consensus"
) %>% 
  left_join(df_criteria, by = c("criteria1" = "criteria")) %>% 
  left_join(df_criteria, by = c("criteria2" = "criteria")) %>% 
  mutate(symptom_pair = map2(feature.x, feature.y, ~sort(c(.x,.y)))) %>% 
  unnest_wider(symptom_pair, names_sep = "") %>% 
  unite(symptom_pair, symptom_pair1, symptom_pair2, sep = " : ") %>% 
  unite(criteria_pair, criteria1, criteria2, sep = " : ") %>% 
  select(criteria_pair, symptom_pair) %>% 
  left_join(symptom_distance_key_euc, by = "symptom_pair") %>% 
  drop_na() %>% 
  mutate(criteria_pair = gsub(" : ", "\nvs. ", criteria_pair)) 
df_compare_euc
```
```{r}
pairwise.wilcox.test(x = df_compare_euc$distance, g = df_compare_euc$criteria_pair, p.adjust.method = "BH") %>% 
  broom::tidy() %>% 
  mutate(p.value = round(p.value, 4)) %>% 
  arrange(desc(p.value))
```


```{r, fig.width=2, fig.height=4}
df_compare_euc %>% 
  ggplot(aes(x = criteria_pair, y = distance))+
  # geom_violin()+
  stat_summary(fun = mean, geom = "point", size = 0.5) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.5)+
  # ggpubr::stat_compare_means(
  #   aes(label = paste0("p = ", after_stat(p.format))), 
  #   method = "wilcox.test",
  #   label.y=56,
  #   vjust=1,
  #   tip.length = 1,
  #   step.increase = 2)+
  ggpubr::stat_pvalue_manual(
    ggpubr::compare_means(distance ~ criteria_pair, df_compare_euc, method = "wilcox.test"),
    label = "p = {p.adj}",
    y.position = 55.6,
    tip.length = 0.001
  )+
  theme_bw() +
  theme(axis.text.x = element_text(angle =90, hjust =1)) +
  labs(x="", y="Euclidean distance") +
  coord_cartesian(ylim=c(NA,55.75))
```




```{r, fig.width=2, fig.height=4, message = F}
symptom_distance_key_cos <- lsa::cosine(t(as.matrix(pca_embedding$x))) %>% 
  as.dist() %>% 
  broom::tidy() %>% 
  mutate_at(vars(contains("item")), as.character) %>% 
  mutate(symptom_pair = map2(item1, item2, ~sort(c(.x,.y)))) %>% 
  unnest_wider(symptom_pair, names_sep = "") %>% 
  unite(symptom_pair, symptom_pair1, symptom_pair2, sep = " : ") %>% 
  select(symptom_pair, distance)


df_compare_cos <- tribble(
  ~criteria1, ~criteria2,
  "SLE - EULAR-ACR", "SLE - SLICC",
  "MCAS - Consortium", "MCAS - Alternative"
  # "SLE - SLICC", "SLE - SLICC",
  # "MCAS - Consensus",  "MCAS - Consensus"
) %>% 
  left_join(df_criteria, by = c("criteria1" = "criteria")) %>% 
  left_join(df_criteria, by = c("criteria2" = "criteria"))  %>% 
  mutate(symptom_pair = map2(feature.x, feature.y, ~sort(c(.x,.y)))) %>% 
  unnest_wider(symptom_pair, names_sep = "") %>% 
  unite(symptom_pair, symptom_pair1, symptom_pair2, sep = " : ") %>% 
  unite(criteria_pair, criteria1, criteria2, sep = " : ") %>% 
  select(criteria_pair, symptom_pair) %>% 
  left_join(symptom_distance_key_cos, by = "symptom_pair") %>% 
  drop_na()

df_compare_cos %>% 
  ggplot(aes(x = criteria_pair, y = distance))+
  geom_boxplot()+
  # geom_violin()+
  # stat_summary(fun = mean, geom = "point") +
  # stat_summary(fun.data = mean_cl_normal, geom = "errorbar")+
  theme_bw()+
  theme(axis.text.x = element_text(angle =90, hjust =1)) +
  labs(x="", y="Cosine distance")
```
### Centroid distance heatmap

```{r, fig.width=4.5, fig.height=4, message = F}
# Plot heatmap of distance between centroids in PCA space
as.data.frame(pca_embedding$x) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "euclidean") %>% 
  pheatmap::pheatmap(color = viridis::viridis(100, direction = -1), main = "Euclidean")

as.data.frame(pca_embedding$x) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "cosine") %>% 
  pheatmap::pheatmap(color = colorRampPalette(RColorBrewer::brewer.pal(11, "BrBG"))(101), main = "Cosine", breaks = seq(-1,1,length.out = 101))
```

```{r}
as.data.frame(pca_embedding$x) %>% 
  # calculate_centroids() %>% 
  custom_dist(method = "cosine")
```



### Dendrogram significance
```{r, fig.width=6, fig.height=6, message = F}
cosine <- function(x) {
  x <- as.matrix(x)
  y <- t(x) %*% x
  res <- 1 - y / (sqrt(diag(y)) %*% t(sqrt(diag(y))))
  res <- as.dist(res)
  attr(res, "method") <- "cosine"
  return(res)
}


pvclust_pca <- as.data.frame(pca_embedding$x) %>% 
  calculate_centroids() %>% 
  t() %>% 
  pvclust::pvclust(nboot = 500, method.dist = cosine, quiet = T)
plot(pvclust_pca)
pvclust::pvrect(pvclust_pca, alpha = 0.95)
```


# UMAP 
```{r, message = F}
# names(umap::umap.defaults)
set.seed(1234)
umap_gpt <- umap::umap(df_embeddings)
# umap_cluster <- umap::umap(df_embeddings, n_components = 2)
```

### UMAP plot

```{r, message = F}
# Plot UMAP of embeddings
umap_gpt$layout %>% 
  as.data.frame() %>% 
  rownames_to_column("feature") %>% 
  left_join(df_criteria) %>% 
  drop_na() %>% 
  ggplot(aes(x=V1, y=V2, color = criteria))+
  geom_point(size = 1) +
  theme_bw() +
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")
```

# Final figure
```{r, fig.width=6, fig.height=6, message=F}
plt_1 <- pca_embedding$x[,c(x,y)] %>% 
  as.data.frame() %>% 
  rownames_to_column("feature") %>% 
  left_join(df_criteria) %>% 
  drop_na() %>% 
  ggplot(aes(x=!!sym(x), y=!!sym(y), color = criteria))+
  geom_point(size = 0.5) +
  geom_point(data = . %>% group_by(criteria) %>% summarise_at(vars(contains("PC")), mean), size = 3, shape = 21, color = "black", aes(fill = criteria))+
  # stat_ellipse(size = 2, type = "t", level = 0.95)+
  # facet_wrap(~criteria) +
  theme_bw()+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2") +
  labs(fill = "", color = "")

plt_2 <- df_compare_euc %>% 
  ggplot(aes(x = criteria_pair, y = distance))+
  stat_summary(fun = mean, geom = "point", size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.5)+
  ggpubr::stat_pvalue_manual(
    ggpubr::compare_means(distance ~ criteria_pair, df_compare_euc, method = "wilcox.test"),
    label = "p = {p.adj}",
    y.position = 55.6,
    tip.length = 0.001
  )+
  theme_bw() +
  theme(axis.text.x = element_text(angle =90, hjust =1)) +
  labs(x="", y="Euclidean distance") +
  coord_cartesian(ylim=c(NA,55.75))

cp_font <- 9
plt_3 <- as.data.frame(pca_embedding$x) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "euclidean") %>% 
  # pheatmap::pheatmap(color = viridis::viridis(100, direction = -1))
  ComplexHeatmap::Heatmap(
    col = viridis::viridis(100, direction = -1), 
    name= "Euclidean\ndistance",
    rect_gp = grid::gpar(col = "black", lwd = 1),
    row_names_gp = grid::gpar(fontsize = cp_font),  # Adjust font size for row labels
  column_names_gp = grid::gpar(fontsize = cp_font)  # Adjust font size for column labels
  )

# cowplot::plot_grid(
# cowplot::plot_grid(plt_1, plt_2, nrow = 1, rel_widths = c(0.7,0.3), align = "h", axis = "tb"),
# cowplot::plot_grid(NULL, plt_3$gtable, NULL, nrow =1, rel_widths = c(0.2, 0.6,0.15)),
# ncol = 1)

plt_fig <- cowplot::plot_grid(
  cowplot::plot_grid(
    NULL,
    plt_1,
    NULL,
    nrow = 1,
    rel_widths = c(0.1, 0.8, 0.1),
    align = "h",
    axis = "tb",
    labels = c("", "A", "")
  ),
  # cowplot::plot_grid(plt_2, NULL, plt_3$gtable, nrow =1, rel_widths = c(0.3, 0.1, 0.7), align = "h", axis = "tb", labels = c("B","C")),
  cowplot::plot_grid(
    plt_2,
    NULL,
    cowplot::plot_grid(
      grid::grid.grabExpr(ComplexHeatmap::draw(plt_3)),
      NULL,
      ncol = 1,
      rel_heights = c(0.9, 0.1)
    ),
    nrow = 1,
    rel_widths = c(0.3, 0.051, 0.7),
    labels = c("B", "", "C")
  ),
  ncol = 1,
  rel_heights = c(0.4, 0.6)
)

plt_fig
```
```{r}
ggsave(here("figures/2_Criteria_embedding.pdf"), plot=plt_fig, height = 6, width = 6)
```

# Altenative layout
```{r, fig.width=7, fig.height=3.5, message=F}
title_size <- 9
label_size <- 6

apply_text_formatting <- list(theme(
  axis.text = element_text(size = label_size),
  axis.title = element_text(size = title_size),
  legend.text = element_text(size = label_size),
  legend.key.height = unit(0.4, 'cm')
  ))

plt_1 <- pca_embedding$x[,c(x,y)] %>% 
  as.data.frame() %>% 
  rownames_to_column("feature") %>% 
  left_join(df_criteria) %>% 
  drop_na() %>% 
  ggplot(aes(x=!!sym(x), y=!!sym(y), color = criteria))+
  geom_point(size = 0.5) +
  geom_point(data = . %>% group_by(criteria) %>% summarise_at(vars(contains("PC")), mean), size = 3, shape = 21, color = "black", aes(fill = criteria))+
  theme_bw()+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2") +
  labs(fill = "", color = "") +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(ncol = 2))

plt_2 <- df_compare_euc %>% 
  ggplot(aes(x = criteria_pair, y = distance))+
  stat_summary(fun = mean, geom = "point", size = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.5)+
  ggpubr::stat_pvalue_manual(
    ggpubr::compare_means(distance ~ criteria_pair, df_compare_euc, method = "wilcox.test"),
    label = "p = {p.adj}",
    y.position = 55.6,
    tip.length = 0.001, label.size = 3
  )+
  theme_bw() +
  theme(axis.text.x = element_text(angle =90, hjust =1)) +
  labs(x="", y="Euclidean distance") +
  coord_cartesian(ylim=c(NA,55.75))

plt_3 <- as.data.frame(pca_embedding$x) %>% 
  calculate_centroids() %>% 
  custom_dist(method = "euclidean") %>% 
  # pheatmap::pheatmap(color = viridis::viridis(100, direction = -1))
  ComplexHeatmap::Heatmap(
    col = viridis::viridis(100, direction = -1), 
    name= "Euclidean distance",
    heatmap_legend_param = list(direction = "horizontal"),
    rect_gp = grid::gpar(col = "black", lwd = 1),
    row_names_gp = grid::gpar(fontsize = label_size),  # Adjust font size for row labels
    column_names_gp = grid::gpar(fontsize = label_size)  # Adjust font size for column labels
  )

plt_fig <- cowplot::plot_grid(
    plt_1 + apply_text_formatting,
    plt_2 + apply_text_formatting,
    grid::grid.grabExpr(ComplexHeatmap::draw(plt_3, heatmap_legend_side = 'bottom')),
    rel_widths = c(0.9, 0.5, 1),
    axis = 'bt',
    align = 'h',
    labels = LETTERS[1:3],
    nrow = 1
)

plt_fig
```

```{r}
ggsave(here("figures/2_Criteria_embedding.pdf"), plot=plt_fig, height = 3.5, width = 7)
```




